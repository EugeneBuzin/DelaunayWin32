#pragma once

#include <string>

using namespace std;

// Содержит структуры данных.
namespace DelaunayStructures
{
	// Идентифицирует вершину, не являющуюся частью триангуляционной сетки,
	// но записываемую в выходной файл *.node и влияющую на индексацию узла.
	// в других выходных файлах.
	const int UNDEADVERTEX = -32767;

	// Треугольник. Каждый треугольник содержит:
	// - три указателя на прилегающие треугольники,
	// - три указателя на вершины,
	// - три указателя на подсегменты(эти указатели обычно являются фиктивными).
	// Треугольник может также содержать или не содержать пользовательские атрибуты
	// и/или  «ограничение области»  с плавающей  точкой. Он  также может содержать
	// дополнительные указатели для узлов, когда  пользователь запрашивает элементы
	// высшего порядка.
	typedef double** Triangle;

	// Вершина треугольника. Каждая вершина на самом деле является
	// массивом  double. Количество элементов в этом массиве  неизвестно до времени
	// выполнения.  После массива  в структуру добавляется  целочисленный граничный
	// маркер, а иногда ещё  и указатель на треугольник.
	typedef double* Vertex;

	// Пул памяти, выделяемой для выполнения триангуляции.
	struct MemoryPool
	{
		// Первый блок элементов.
		void** FirstBlock;
		// Блок, с которого выполняется текущее выделение элементов.
		void** CurrentAllocationBlock;
		// Указатель на следующий кусок свободной памяти для элемента.
		void* NextFreeMemorySlice;
		// Заголовок связанного списка, представляющего стек элементов,
		// память из под которых была освобождена.
		void* DeadElementsStack;
		// Указатель на текущий блок элементов, в котором выполняется триангуляция.
		void** CurrentTriangulatedBlock;
		// Указатель на следующий триангулируемый элемент.
		void* NextItemForTriangulation;
		// Определяет, как будут выравниваться в памяти новые записи.
		int AlignBytes;
		// Длина записи в байтах (после округления в большую сторону).
		int ItemBytes;
		// Количество предметов, одновременно выделенных в одном блоке.
		int ItemsPerBlock;
		// Количество элементов в первом блоке.
		int ItemsFirstBlock;
		// Количество элементов, выделенных в настоящее время.
		long CurrentlyAllocatedItems;
		// Максимальное количество одновременно выделяемых элементов. Представляет
		// текущее количество элементов и количество записей в стеке элементов, из
		// под которых была освобождена память.
		long MaxItems;
		// Количество элементов, под которые осталось выделить память из текущего блока
		int UnallocatedItems;
		// Количество элементов в текущем блоке триангулируемых элементов (CurrentTriangulatedBlock),
		// которые осталось протриангулировать.
		int PathItemsLeft;
	};

	// Ориентированный треугольник.
	struct OTriangle {
		// Указатель на треугольник,
		Triangle* Tri;
		// Ориентация - направление следования рёбрер треугольника:  по  часовой стрелке,
		// против часовой стрелки.  Диапазон  значений ориентации - от 0 до 2,  т.к. есть
		// три возможных ориентации. По соглашению, каждое ребро всегда направлено против 
		// часовой стрелки относительно своего треугольника.
		int Orient;
	};

	// Триангуляционная сетка.
	struct Mesh {
		// Выделение памяти для треугольников.
		MemoryPool Triangles;
		// Выделение памяти для вершин треугольников. 
		MemoryPool Vertices;
		// Граничные значения X и Y.
		double X_Min, X_Max, Y_Min, Y_Max;
		// Количество входных вершин.
		int InVertices;
		// Количество входных вершин, не показывающихся в сетке.
		int UnshownVertices;
		// Количество всех рёбер выпуклой оболочки по завершению триангуляции.
		long Edges;
		// Измерение триангуляционной сетки (следует быть равным 2, т.к. сетка - двухмерна).
		int MeshDimension;
		// Количество атрибутов на вершину.
		int AttributesPerVertex;
		// Количество атрибутов на треугольник.
		int AttributesPerTriangle;
		// Количество ребер, ограничивающих выпуклую оболочку по её краям.
		long HullSize;
		// Индекс для поиска граничного маркера вершины.
		int VertexMarkIndex;
		// Индекс для поиска дополнительных узлов для элементов внешнего порядка.
		int HighOrderIndex;
		// Индекс для поиска атрибутов треугольника.
		int ElemAttribIndex;
		// Индекс для нахождения границы области треугольника.
		int AreaBoundIndex;
		// Проверка того, был ли прочитан файл .node (файл с облаком точек).
		int ReadNodeFile;
		// Указатель на 'треугольник', который занимает всё "наружное пространство".
		Triangle *DummyTri;
		// Буфер для базового адреса треугольника.
		Triangle *DummyTriBase;
	};

	// Обеспечивает доступ к ключам, используемым в командной строке, и именам файлов.
	struct Configuration {
		// Флаг нумерации вершин начиная от нуля (0).
		int firstnumber;
		// Флаг вывода в файл *.neigh списка треугольников, соседствующих с каждым треугольником.
		int neighbors;
		// Флаг отсутствия граничных маркеров в выходных данных *.node, *.poly и *.edge файлов.
		int nobound;
		// Флаг отключения использования точной арифметики при триангуляции.
		int noexact;
		// Флаг применения только вертикальных разбиениий множества триангулируемых вершин
		// в алгоритме «разделяй и властвуй» (если этот флаг установлен в 0). По умолчанию,
		// (если этот флаг установлен в 1) Triangle чередует вертикальные и горизонтальные
		// разбиения, что обычно увеличивает скорость триангуляции.
		int dwyer;
		// Флаг создания субпараметрических элементов второго порядка с шестью узлами каждый.
		int order;
		// Переменные для имён файлов.
		// Входной файл исходных точек для триангуляции.
		wstring InNodeFileName;
		// Выходной файл вершин триангуляционной сетки.
		wstring OutNodeFileName;
		// Выходной файл треугольников.
		wstring OutEleFileName;
		// Файл рёбер треугольников.
		wstring OutEdgeFileName;
		// Файл соседних треугольников (треугольников-соседей).
		wstring OutNeighborFileName;
	};
}
